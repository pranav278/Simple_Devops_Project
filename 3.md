### C

* login to docker-server and login as a root user

* Create a `docker` folder within the `/opt` directory, you can use the following commands in a Unix-like system (such as Linux):

```bash
cd /opt
mkdir docker
```


![image](https://github.com/pranav278/Simple_Devops_Project/assets/84725860/a0d4205f-bb04-408a-8a61-b54bd54cf93f)

![image](https://github.com/pranav278/Simple_Devops_Project/assets/84725860/acf70d43-a2c7-413e-996b-5c4bfea138fb)

The `chown` command is used to change the ownership of files and directories. The `-R` option indicates that the operation should be recursive, applying changes to all files and subdirectories within the specified directory.

To change the ownership of the `docker` directory and all its contents to a user and group named `dockeradmin`, you can use the following command:

```bash
chown -R dockeradmin:dockeradmin /opt/docker
```

This command will change the owner (`dockeradmin`) and group (`dockeradmin`) of the `/opt/docker` directory and all its contents recursively. Again, the `sudo` command is used to execute the `chown` command with superuser privileges.


![image](https://github.com/pranav278/Simple_Devops_Project/assets/84725860/87dbfc02-3f6e-4ffa-822f-42db3ec04fa2)

```bash
mv /root/Dockerfile /opt/docker/
```

This command will move the `Dockerfile` from the `/root` directory to the `/opt/docker` directory. After executing this command, the `Dockerfile` will no longer be in the `/root` directory; it will be located in `/opt/docker`.

![image](https://github.com/pranav278/Simple_Devops_Project/assets/84725860/77bb5fb5-7a73-497a-a8a9-d4f141fa1333)

To change the ownership of the `/opt/docker` directory and all its contents to the `dockeradmin` user and `dockeradmin` group, you can use the `chown` command with the `-R` option, like this:

```bash
sudo chown -R dockeradmin:dockeradmin /opt/docker
```

This command will recursively change the owner and group of all files and directories within `/opt/docker` to `dockeradmin:dockeradmin`. Remember to use `sudo` if you need superuser privileges to perform this operation.

![image](https://github.com/pranav278/Simple_Devops_Project/assets/84725860/18b87105-7064-4702-9878-110a5235c77a)ange 

* Now lets change the Jenkins Configuration 

Configuring a deployment in Jenkins to transfer files from a local directory to a remote directory. Let's break down your configuration:

1. **Remove prefix**: This option typically specifies a prefix that should be removed from the source directory structure before transferring files. Since you're specifying `webapp/target`, it implies that you want to remove the prefix `webapp/target` from the directory structure.

2. **Remote directory**: This specifies the destination directory on the remote server where the files should be transferred. In your case, it's `//opt//docker`. However, it seems like there might be an issue with the double slashes (`//`) in the path. Usually, directory paths are specified with single slashes (`/`). Assuming you meant `/opt/docker`, I will use that in the explanation.

To add this configuration in Jenkins:

1. Go to your Jenkins project's configuration page.
2. Look for the section related to deployment or file transfer (often found under "Post-build Actions" or "Build" or "Publish over SSH" depending on your setup).
3. Fill in the fields as follows:
   - For "Remove prefix," enter `webapp/target`.
   - For "Remote directory," enter `/opt/docker`.

This configuration tells Jenkins to transfer files from `webapp/target` on the local machine to `/opt/docker` on the remote server, while also removing the prefix `webapp/target` from the directory structure during the transfer. Make sure to adjust the paths according to your specific directory structure and requirements.

![image](https://github.com/pranav278/Simple_Devops_Project/assets/84725860/e4d0655f-27dd-4168-a86a-4df05d0607f8)

* lets do some changes in docker file to copy artifcats

Create a Dockerfile for deploying a web application (`webapp.war`) to Tomcat. Let's break down the Dockerfile:

```Dockerfile
FROM tomcat:latest

RUN cp -R /usr/local/tomcat/webapps.dist/* /usr/local/tomcat/webapps
COPY ./webapp.war /usr/local/tomcat/webapps
```

Here's what each line does:

- `FROM tomcat:latest`: This line specifies the base image for your Dockerfile. In this case, it uses the latest version of the official Tomcat image available on Docker Hub.

- `RUN cp -R /usr/local/tomcat/webapps.dist/* /usr/local/tomcat/webapps`: This line copies the contents of the `webapps.dist` directory to the `webapps` directory in Tomcat. This step is commonly used to initialize the deployment directory structure in Tomcat. The `-R` option ensures that it recursively copies all files and directories.

- `COPY ./webapp.war /usr/local/tomcat/webapps`: This line copies the `webapp.war` file from the local filesystem into the `webapps` directory of Tomcat. This is how you deploy your web application to Tomcat. 

Assuming you have the `webapp.war` file in the same directory as your Dockerfile, this Dockerfile will effectively deploy your `webapp.war` file onto Tomcat. Make sure to build and run the Docker container appropriately after creating this Dockerfile.

![image](https://github.com/pranav278/Simple_Devops_Project/assets/84725860/c8ed0659-10b5-4d8e-8cdb-35a11ad2fc87)

![image](https://github.com/pranav278/Simple_Devops_Project/assets/84725860/473aae1b-e3a6-4cb9-8e72-769b90677437)

To build a Docker image named `tomcat` with the tag `v1` using the Dockerfile in the current directory, you would use the `docker build` command as follows:

```bash
docker build -t tomcat:v1 .
```

This command tells Docker to build an image based on the Dockerfile (`.` represents the current directory), and tag it with `tomcat:v1`. After running this command, Docker will execute the instructions in the Dockerfile to create the image. Once the build process completes, you'll have a Docker image named `tomcat` with the tag `v1` available on your system.




```bash
docker run -d --name tomcatv1 -p 8086:8080 tomcat:v1
```

This command will run a container based on the `tomcat:v1` image in detached mode (`-d`), with the name `tomcatv1` (`--name tomcatv1`), and expose port `8080` of the container to port `8086` on the host (`-p 8086:8080`).

![image](https://github.com/pranav278/Simple_Devops_Project/assets/84725860/fbe6d820-9d98-4ce5-a334-8c1608c900cb)

* Now check our tomcat server is up 

![image](https://github.com/pranav278/Simple_Devops_Project/assets/84725860/bbc6778d-b20c-4847-9161-ad1634dedce9)









